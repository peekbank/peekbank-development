---
title: "Subject-level developmental relationships"
format: html
---

```{r}
suppressPackageStartupMessages(library(here))
suppressPackageStartupMessages(library(psych))
suppressPackageStartupMessages(source(here("helper","common.R")))
d_sub <- readRDS(here("cached_intermediates","1_d_sub.Rds"))
```


# Relations between variables

## Between datasets

```{r}
cor(select(d_sub, age, log_age, rt, log_rt, 
                       short_window_accuracy, long_window_accuracy, 
                       short_window_elogit, long_window_elogit, prod, comp), 
    use = "pairwise.complete.obs") |>
  round(2)
```

Take a look at correlations to select variables. 

```{r, fig.width=9, fig.height=9}
GGally::ggpairs(select(d_sub, age, log_age, rt, log_rt, 
                       short_window_accuracy, long_window_accuracy, 
                       short_window_elogit, long_window_elogit, prod, comp), 
                progress = FALSE, lower = list(continuous = GGally::wrap("points", alpha = 0.03)))

```

Let's select the most interesting of these. 

```{r, fig.width=9, fig.height=9}
d_sub |>
  select(log_age, log_rt,  
         long_window_accuracy,  prod, comp) |>
GGally::ggpairs(progress = FALSE, 
                lower = list(continuous = GGally::wrap("points", alpha = 0.03)))

```

## Within dataset

All the variables. 


```{r}
all_corrs <- d_sub |>
select(dataset_name, age, log_age, rt, log_rt, 
                       short_window_accuracy, long_window_accuracy, 
                       short_window_elogit, long_window_elogit, prod, comp) |>
  group_by(dataset_name) |>
  nest() |>
  mutate(corrs = map(data, ~cor(.x, use = "pairwise.complete.obs")),
         long_corrs = map(corrs, ~pivot_longer(as_tibble(.x) |> 
                                                mutate(variable1 = colnames(.x)), 
                                               -variable1, names_to = "variable2", 
                                               values_to = "r"))) |>
  select(-data, -corrs) |>
  unnest(cols = c(long_corrs))

ggplot(all_corrs, aes(x = variable1, y = r, col = dataset_name)) + 
  geom_point(alpha = .2) + 
  stat_summary(fun.data = "mean_cl_boot", col = "black") +
  coord_flip() + 
  facet_wrap(~variable2)
```

Several variables. 

```{r}
d_sub_agevar <- d_sub |>
  filter(dataset_name %in% datasets_with_age_variation$dataset_name)


all_corrs <- d_sub_agevar |>
select(dataset_name, log_age, log_rt, rt,
                       long_window_accuracy, long_window_elogit) |>
  group_by(dataset_name) |>
  nest() |>
  mutate(corrs = map(data, ~cor(.x, use = "pairwise.complete.obs")),
         long_corrs = map(corrs, ~pivot_longer(as_tibble(.x) |> 
                                                mutate(variable1 = colnames(.x)), 
                                               -variable1, names_to = "variable2", 
                                               values_to = "r"))) |>
  select(-data, -corrs) |>
  unnest(cols = c(long_corrs)) |>
  filter(variable1 != variable2, 
         !(variable1 == "rt" & variable2 == "log_rt"), 
         !(variable1 == "log_rt" & variable2 == "rt"),
         !(variable1 == "long_window_accuracy" & variable2 == "long_window_elogit"),
         !(variable1 == "long_window_elogit" & variable2 == "long_window_accuracy"))

ggplot(all_corrs,
       aes(x = variable1, y = r, col = dataset_name)) + 
  geom_point(alpha = .5, pch = 20) +
  stat_summary(fun.data = "mean_cl_boot", aes(group = 1)) +
  geom_hline(yintercept = 0, lty = 2) + 
  # coord_flip() +
  facet_grid(.~variable2, scales = "free_x") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

Plot correlations of key variables now.  Annoying to figure out how to remove the upper diagonal...

```{r}
all_corrs <- d_sub_agevar |>
select(dataset_name, log_age, log_rt,
                       long_window_accuracy) |>
  group_by(dataset_name) |>
  nest() |>
  mutate(corrs = map(data, ~cor(.x, use = "pairwise.complete.obs")),
         long_corrs = map(corrs, ~pivot_longer(as_tibble(.x) |> 
                                                mutate(variable1 = colnames(.x)), 
                                               -variable1, names_to = "variable2", 
                                               values_to = "r"))) |>
  select(-data, -corrs) |>
  unnest(cols = c(long_corrs)) |>
  filter(variable1 != variable2)

ggplot(all_corrs,
       aes(x = interaction(variable1, variable2), y = r, col = dataset_name)) + 
  geom_point(alpha = .5, pch = 20) +
  stat_summary(fun.data = "mean_cl_boot", aes(group = 1)) +
  geom_hline(yintercept = 0, lty = 2) + 
  coord_flip() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```




# Individual relationships

```{r}
m_rt <- mean(d_sub$rt, na.rm=TRUE)
sd_rt <- sd(d_sub$rt, na.rm=TRUE)
d_sub$factor_rt <- cut(d_sub$rt, 
                           breaks = quantile(d_sub$rt, 
                                             probs = c(0, .25, .5, .75, 1), 
                                             na.rm= TRUE), 
                           labels = c("0-25", "25-50", "50-75", "75-1"))


ggplot(filter(d_sub, !is.na(rt), !is.na(factor_rt)),
       aes(x = age, 
           y = long_window_accuracy, 
           col = factor_rt)) +
  geom_point(alpha = .3) +
  geom_smooth() +
  scale_x_log10() + 
  geom_hline(yintercept = .5, lty = 2)+
  viridis::scale_color_viridis(discrete = TRUE, 
                               name = "RT quantile") + 
  xlab("Age (log months)") + 
  ylab("Accuracy (long window)") + 
  theme(legend.position = "bottom")

```

Broken out by age group.

```{r}

d_sub$age_group <- cut(d_sub$log_age, 
                           breaks = log(c(12,24,36,48,60)), 
                           labels = c("12-24","24-36","36-48","48-60"), 
                           include_lowest = TRUE)


ggplot(filter(d_sub, !is.na(age_group)), 
       aes(x = rt, 
           y = long_window_accuracy, 
           col = age_group)) +
  geom_point(alpha = .3) +
  geom_smooth() +
  geom_hline(yintercept = .5, lty = 2)+
  viridis::scale_color_viridis(discrete = TRUE, 
                               name = "age group")
```

By dataset.

```{r}
datasets_with_age_variation <- d_trial |>
  group_by(dataset_name) |>
  summarise(age_range = max(age) - min(age)) |>
  filter(age_range >= 4)

ggplot(filter(d_sub, 
              !is.na(rt), !is.na(factor_rt), 
              dataset_name %in% datasets_with_age_variation$dataset_name),
       aes(x = age, 
           y = long_window_accuracy, 
           col = factor_rt)) +
  geom_point(alpha = .3) +
  geom_smooth(se= FALSE, method = "lm") +
  scale_x_log10() + 
  geom_hline(yintercept = .5, lty = 2)+
  viridis::scale_color_viridis(discrete = TRUE, 
                               name = "RT quantile") +
  facet_wrap(~dataset_name) + 
  xlab("Age (log months)") + 
  ylab("Accuracy (long window)")

```

# Dimensionality reduction

The claim of some of the Fernald processing corpus is that there is a second principal component here (namely, processing speed) that is meaningful and relates to later learning outcomes.



## Production


Scree plot

```{r}
d_sub_mat <- d_sub |>
  ungroup() |>
  select(log_age, log_rt, long_window_elogit, prod) 

d_sub_mat <- d_sub_mat |>
  filter(complete.cases(d_sub_mat)) |>
  as.matrix() 

fa.parallel(d_sub_mat)
```

Factor analysis first. This is probably more appropriate. 

```{r}
mod1 <- fa(d_sub_mat, 1, rotate = "varimax")
mod2 <- fa(d_sub_mat, 2, rotate = "varimax")

summary(mod1)
mod1
```

Make into matrices and look at PCA. 

```{r}

acc_rt_prc <- prcomp(x = d_sub_mat, scale = TRUE)

acc_rt_prc
summary(acc_rt_prc)
ggbiplot::ggbiplot(acc_rt_prc, alpha = .1)
```

## Production within individual datasets

```{r}
d_sub_mat_dataset <- d_sub |>
  filter(dataset_name %in% datasets_with_age_variation$dataset_name) |>
  group_by(dataset_name) |>
  select(dataset_name, log_age, log_rt, long_window_elogit, prod) 

d_sub_mat_grp <- d_sub_mat_dataset |>
  nest() |>
  mutate(complete_data = map(data, ~filter(.x[complete.cases(.x),])),
    mat = as.matrix(complete_data), 
    has_data = map_lgl(complete_data, ~nrow(.x)>0)) |>
  filter(has_data) |>
  mutate(factors = map(mat, ~fa(.x, 1, rotate = "varimax")), 
         f_summary = map(factors, summary), 
         loadings = map_df(factors, ~as.tibble(loadings(x))))

d_sub_mat_grp |>
  

```



## Comprehension


```{r}
d_sub_mat_comp <- d_sub |>
  ungroup() |>
  select(log_age, log_rt,  long_window_elogit, comp) 

d_sub_mat_comp <- d_sub_mat_comp |>
  filter(complete.cases(d_sub_mat_comp)) |>
  as.matrix() 

```

Scree.

```{r}
fa.parallel(d_sub_mat_comp)
```

Factor analysis

```{r}
mod1_comp <- fa(d_sub_mat_comp, 1, rotate = "varimax")
mod2_comp <- fa(d_sub_mat_comp, 2, rotate = "varimax")

summary(mod1_comp)
loadings(mod1_comp)
```

PCA.

```{r}
acc_rt_prc_comp <- prcomp(x = d_sub_mat_comp, scale = TRUE)

acc_rt_prc_comp
summary(acc_rt_prc_comp)
ggbiplot::ggbiplot(acc_rt_prc_comp, alpha = .1)
```

# Longitudinal data

```{r}
longitudinal <- d_sub |>
  group_by(dataset_name, subject_id) |>
  count() |>
  filter(n > 1)

d_sub_long <- d_sub |>
  filter(subject_id %in% longitudinal$subject_id, 
                     !is.na(prod)) |>
  group_by(subject_id) |>
  arrange(administration_id) |>
  mutate(admin_num = 1:n(), 
         delta_t = c(0,diff(age)))
  
ggplot(filter(d_sub_long, admin_num > 1), 
       aes(x = delta_t)) +
  geom_histogram()
```

```{r}

```


```{r}
library(lavaan)

```



# Conclusions

The next thing to do is look at any longitudinal data we have, to see how predictive faster LWL at t0 is of higher CDIs at t1.

