---
title: "Subject-level developmental relationships"
format: html
---

```{r}
suppressPackageStartupMessages(library(here))
suppressPackageStartupMessages(source(here("helper","common.R")))
d_sub <- readRDS(here("cached_intermediates","1_d_sub.Rds"))
load(here("..", "peekbank-method", "cached_intermediates", "1_cdi_subjects.Rds"))
```


This is broken due to some repeated fields. 

```{r}
d_cdi <- cdi_data |>
  select(administration_id, native_language, measure, language, 
         CDI_percent) |> # rawscore is form-dependent
  filter(language == "English (American)", native_language == "eng") |>
  pivot_wider(names_from = "measure", values_from = "CDI_percent", 
              values_fill = NA, values_fn = mean)
```


```{r}
d_sub_cdi <- d_sub |>
  left_join(d_cdi) |>
  mutate(log_age = log(age)) |>
  ungroup()
```


# Relation between RT and accuracy 

Take a look at correlations to select variables. 

```{r, fig.width=9, fig.height=9}
GGally::ggpairs(select(d_sub_cdi, age, log_age, rt, log_rt, 
                       short_window_accuracy, long_window_accuracy, 
                       short_window_elogit, long_window_elogit, prod, comp), 
        progress = FALSE, lower = list(continuous = GGally::wrap("points", alpha = 0.03)))

```

Let's select the best of these. 

```{r, fig.width=9, fig.height=9}
GGally::ggpairs(select(d_sub_cdi, log_age, rt,  
                       long_window_accuracy, short_window_accuracy, prod, comp), 
        progress = FALSE, lower = list(continuous = GGally::wrap("points", alpha = 0.03)))

```

# Individual relationships

```{r}
m_rt <- mean(d_sub_cdi$rt, na.rm=TRUE)
sd_rt <- sd(d_sub_cdi$rt, na.rm=TRUE)
d_sub_cdi$factor_rt <- cut(d_sub_cdi$rt, 
                           breaks = quantile(d_sub_cdi$rt, 
                                             probs = c(0, .25, .5, .75, 1), 
                                             na.rm= TRUE))
                           

ggplot(filter(d_sub_cdi, !is.na(rt), !is.na(factor_rt)),
       aes(x = log_age, 
                      y = long_window_accuracy, 
                      col = factor_rt)) +
  geom_point(alpha = .3) +
  geom_smooth() +
  geom_hline(yintercept = .5, lty = 2)+
  viridis::scale_color_viridis(discrete = TRUE, 
                               name = "RT quantile")

```

Broken out by age group.

```{r}

d_sub_cdi$age_group <- cut(d_sub_cdi$log_age, 
                           breaks = log(c(12,24,36,48,60)), 
                           labels = c("12-24","24-36","36-48","48-60"), 
                           include_lowest = TRUE)
                           

ggplot(d_sub_cdi, 
       aes(x = rt, 
                      y = long_window_accuracy, 
                      col = age_group)) +
  geom_point(alpha = .3) +
  geom_smooth() +
  geom_hline(yintercept = .5, lty = 2)+
  viridis::scale_color_viridis(discrete = TRUE, 
                               name = "age group")
```

<!-- By dataset.  -->

<!-- ```{r} -->
<!-- ggplot(acc_rt, aes(x = log_rt, y = elogit, col = log_age)) + -->
<!--   geom_point(alpha = .3) + -->
<!--   geom_smooth(method = "lm") + -->
<!--   geom_hline(yintercept = .5, lty = 2) + -->
<!--   facet_wrap(~dataset_name) +  -->
<!--   xlab("Mean log RT") +  -->
<!--   ylab("Mean elogit accuracy") -->

<!-- ``` -->

## Dimensionality reduction

Make into matrices.

```{r control-for-age}
d_sub_cdi_mat <- d_sub_cdi |>
  ungroup() |>
  select(age, rt,  long_window_accuracy, prod) |>
  mutate(rt = scale(rt / age)[,1],
         long_window_accuracy = scale(long_window_accuracy / age)[,1], 
         prod = scale(prod / age)[,1]) |>
  select(-age)

d_sub_cdi_mat <- d_sub_cdi_mat |>
  filter(complete.cases(d_sub_cdi_mat)) |>
  as.matrix() 

acc_rt_prc <- prcomp(d_sub_cdi_mat, 2)

acc_rt_prc
summary(acc_rt_prc)
ggbiplot::ggbiplot(acc_rt_prc, alpha = .1)
```

Controlling for age, the first component (~49% of variance) represents high production, fast RT, but low LWL accuracy.
The second component (~31% of variance) captures slow RT, low accuracy, and moderate production, and the third component (~20%) captures fast RT, low accuracy, and low production).

The claim of some of the Fernald processing corpus is that there is a second principal component here (namely, processing speed) that is meaningful and relates to later learning outcomes.

```{r}
d_sub_cdi_mat <- d_sub_cdi |>
  ungroup() |>
  select(log_age, rt,  long_window_accuracy, prod) |>
  mutate(log_age = scale(log_age)[,1], 
         rt = scale(rt)[,1],
         long_window_accuracy = scale(long_window_accuracy)[,1], 
         prod = scale(prod)[,1])

d_sub_cdi_mat <- d_sub_cdi_mat |>
  filter(complete.cases(d_sub_cdi_mat)) |>
  as.matrix() 
```

Factor analysis

```{r}
# scree(d_sub_cdi_mat, pc=FALSE)  # Use pc=FALSE for factor analysis

# install.packages("psych")
mod1 <- fa(d_sub_cdi_mat, 1)
mod2 <- fa(d_sub_cdi_mat, 2)

```



Let's do principal components analysis over the scaled variables. 

```{r}

acc_rt_prc <- prcomp(d_sub_cdi_mat, 2)

acc_rt_prc
summary(acc_rt_prc)
ggbiplot::ggbiplot(acc_rt_prc, alpha = .1)
```

There is a first component capturing ~50% of the variance that is low accuracy, low production, slower, and younger.
A second component capturing ~30% of the variance is higher accuracy, low production, fast RT, and slightly young.
A third component (~16%) is older, highly accurate, low production, and somewhat slow RT.

# Conclusions

The next thing to do is look at any longitudinal data we have, to see how predictive faster LWL at t0 is of higher CDIs at t1.

